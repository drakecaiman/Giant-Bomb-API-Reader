//
//  OpenAPI.swift
//  Giant Bomb API Reader
//
//  Created by Duncan on 1/19/22.
//

import Foundation

struct OpenAPI : Codable
{
  var openapi : String
  var info : Info
  var servers : [Server]?
  var paths : [String : PathItem]
  var components : Components
}

struct Info : Codable
{
  var title : String
  var description : String? = nil
  var version : String
}

struct Server : Codable
{
  var url : URL
  var description : String? = nil
//  var variables : [String : ServerVariable]
}

struct PathItem : Codable
{
  var summary : String? = nil
  var description : String? = nil
  var get : Operation? = nil
}

struct Operation : Codable
{
  var parameters : [Parameter]? = nil
  var responses : Responses
  var security : [[String : [String]]]? = nil
}

struct Components : Codable
{
  var schemas : [ String : Schema ]? = nil
  var securitySchemes : [ String : SecurityScheme]? = nil
}

struct Responses
{
  
  var defaultResponse : Response? = nil
  var responses : [ String : Response ]? = nil
}

extension Responses : Codable
{
  struct CodingKeys : CodingKey
  {
    static let DEFAULT_KEY = "default"
    static let defaultResponseCodingKey = CodingKeys(stringValue: DEFAULT_KEY)!
    
    var stringValue : String
    var intValue: Int? { nil }

    init?(stringValue: String) {
      self.stringValue = stringValue
    }
    
    init?(intValue: Int) {
      return nil
    }
  }
  
  init(from decoder: Decoder) throws
  {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.defaultResponse = try container.decode(Response.self, forKey: CodingKeys(stringValue: CodingKeys.DEFAULT_KEY)!)
    self.responses = [String:Response]()
    for nextKey in container.allKeys.filter({ $0.stringValue != CodingKeys.DEFAULT_KEY })
    {
      self.responses![nextKey.stringValue] = try container.decode(Response.self, forKey: nextKey)
    }
  }
  
  func encode(to encoder: Encoder) throws
  {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if self.defaultResponse != nil { try container.encode(defaultResponse, forKey: .defaultResponseCodingKey) }
    for (nextStatusCode, nextResponse) in self.responses ?? [:]
    {
      try container.encode(nextResponse, forKey: CodingKeys(stringValue: nextStatusCode)!)
    }
  }
}

struct Response : Codable
{
  var description : String
  var content : [String : MediaType]
}

struct MediaType : Codable
{
  var schema : Schema?
}

struct Schema : Codable
{
  var type : String
  var description : String?
  var properties : [String : Property]
}

enum APILocation : String, Codable
{
  case query
  case header
  case path
  case cookie
}

struct SecurityScheme : Codable
{
  enum CodingKeys : String, CodingKey
  {
    case type
    case description
    case name
    case location = "in"
  }
  
  enum SecuritySchemeType : String, Codable
  {
    case apiKey
    case http
    case oauth2
    case openIdConnect
  }

  var type : SecuritySchemeType
  var description : String? = nil
  var name : String
  var location : APILocation
//  scheme  string  http  REQUIRED. The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry.
//  bearerFormat  string  http ("bearer")  A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.
//  flows  OAuth Flows Object  oauth2  REQUIRED. An object containing configuration information for the flow types supported.
//  openIdConnectUrl  string  openIdConnect  REQUIRED. OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL.
}

struct Property : Codable
{
  var type : String
  var description : String
}

struct Parameter : Codable
{
  enum CodingKeys : String, CodingKey
  {
    case name
    case description
    case location = "in"
    case isRequired = "required"
  }
  
  var name : String
  var description : String? = nil
  var location : APILocation
  var isRequired : Bool
}

struct SecurityRequirement
{
//  TODO: Use
}
